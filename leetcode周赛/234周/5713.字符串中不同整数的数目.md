---
tags: 双指针
---





给你一个字符串 `word` ，该字符串由数字和小写英文字母组成。

请你用空格替换每个不是数字的字符。例如，`"a123bc34d8ef34"` 将会变成 `" 123 34 8 34"` 。注意，剩下的这些整数间至少要用一个空格隔开：`"123"`、`"34"`、`"8"` 和 `"34"` 。

返回对 `word` 完成替换后形成的 **不同** 整数的数目。

如果两个整数的 **不含前导零** 的十进制表示不同，则认为这两个整数也不同。

 

**示例 1：**

```
输入：word = "a123bc34d8ef34"
输出：3
解释：不同的整数有 "123"、"34" 和 "8" 。注意，"34" 只计数一次。
```

**示例 2：**

```
输入：word = "leet1234code234"
输出：2
```

**示例 3：**

```
输入：word = "a1b01c001"
输出：1
解释："1"、"01" 和 "001" 视为同一个整数的十进制表示，因为在比较十进制值时会忽略前导零的存在。
```

 

**提示：**

- `1 <= word.length <= 1000`
- `word` 由数字和小写英文字母组成

这题比较蛋疼，首先不能用整型来存储数字，因为单词的长度 `<= 1000` （开始没看到，淦）

使用字符串存储要去掉前导的 0（但是不能去掉中间的 0 ）

```cpp
class Solution 
{
typedef long long LL;
public:
    int numDifferentIntegers(string word) 
    {
        set<string> s;
        
        for(int i = 0; i < word.length(); ++i)
        {
            string x;
            bool flg = false;
            while(i < word.length() && isdigit(word[i]))
            {
                if(x.length() || word[i] != '0')
                {
                    x += word[i];
                }
                i++;
                flg = true;
            }
            
            if(flg)
            {
                s.insert(x);
                i--;
            }
        }
        
        return s.size();
    }
};
```



y总做法：

```cpp
class Solution {
public:
    int numDifferentIntegers(string word) {
        unordered_set<string> nums;
        for (int i = 0; i < word.size(); i ++ ) {
            if (!isdigit(word[i])) continue;
            string s;
            int j = i;
            while (j < word.size() && isdigit(word[j])) s += word[j ++ ];
            int k = 0;
            while (k + 1 < s.size() && s[k] == '0') k ++ ;
            nums.insert(s.substr(k));
            i = j;
        }
        return nums.size();
    }
};
```

