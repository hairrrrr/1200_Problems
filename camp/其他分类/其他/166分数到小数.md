---
tags: 模拟 字符串处理 哈希
---





给定两个整数，分别表示分数的分子 numerator 和分母 denominator，以 字符串形式返回小数 。

如果小数部分为循环小数，则将循环的部分括在括号内。

如果存在多个答案，只需返回 任意一个 。

对于所有给定的输入，保证 答案字符串的长度小于 10^4 。

```
示例 1：

输入：numerator = 1, denominator = 2
输出："0.5"
示例 2：

输入：numerator = 2, denominator = 1
输出："2"
示例 3：

输入：numerator = 2, denominator = 3
输出："0.(6)"
示例 4：

输入：numerator = 4, denominator = 333
输出："0.(012)"
示例 5：

输入：numerator = 1, denominator = 5
输出："0.2"
```

 


提示：

-231 <= numerator, denominator <= 231 - 1
denominator != 0

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/fraction-to-recurring-decimal
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。



[题解](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/fen-shu-dao-xiao-shu-by-leetcode/)

```cpp
class Solution {
typedef long long LL;
public:
    string fractionToDecimal(int numerator, int denominator) 
    {
        if(numerator == 0) return "0";
        //if(denominator == 0)
        // 最大的负数除以 - 1 会爆 int
        LL nume = numerator;
        LL deno = denominator;
        string ans;
        
        if(nume < 0 ^ deno < 0) ans += '-';
        nume = abs(nume);
        deno = abs(deno);
        
        ans += to_string(nume / deno);
        LL r = nume % deno;
        
        if(r == 0) return ans;
        
        ans += ".";

        unordered_map<LL, int> um;

        while(r != 0)
        {
            if(um.find(r) != um.end())
            {
                ans.insert(um.find(r)->second, "(");
                ans += ")";
                break;
            }
            // insert 是在 pos 位置前插，所以这里不能 - 1
            um[r] = ans.length();
            r *= 10;
            ans += to_string(r / deno);
            
            r %= deno;
        }

        return ans;
    }
};
```



